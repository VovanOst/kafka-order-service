-- Создание базы данных для kafka-order-service

-- Таблица заказов
CREATE TABLE IF NOT EXISTS orders (
    id UUID PRIMARY KEY,
    customer_id UUID NOT NULL,
    email VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded')),
    total_amount DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    currency VARCHAR(3) NOT NULL DEFAULT 'USD',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Таблица элементов заказов
CREATE TABLE IF NOT EXISTS order_items (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    total DECIMAL(10,2) NOT NULL
);

-- Таблица адресов заказов
CREATE TABLE IF NOT EXISTS order_addresses (
    id UUID PRIMARY KEY,
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL CHECK (type IN ('shipping', 'billing')),
    street VARCHAR(255) NOT NULL,
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    country VARCHAR(100) NOT NULL,
    zip_code VARCHAR(20) NOT NULL
);

-- Индексы для оптимизации запросов

-- Индексы для таблицы orders
CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders(customer_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_email ON orders(email);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at);
CREATE INDEX IF NOT EXISTS idx_orders_updated_at ON orders(updated_at);
CREATE INDEX IF NOT EXISTS idx_orders_total_amount ON orders(total_amount);
CREATE INDEX IF NOT EXISTS idx_orders_customer_status ON orders(customer_id, status);
CREATE INDEX IF NOT EXISTS idx_orders_status_created ON orders(status, created_at DESC);

-- Индексы для таблицы order_items
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product_id ON order_items(product_id);

-- Индексы для таблицы order_addresses
CREATE INDEX IF NOT EXISTS idx_order_addresses_order_id ON order_addresses(order_id);
CREATE INDEX IF NOT EXISTS idx_order_addresses_type ON order_addresses(order_id, type);

-- Функция для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Триггер для автоматического обновления updated_at в таблице orders
CREATE TRIGGER update_orders_updated_at 
    BEFORE UPDATE ON orders 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Функция для проверки валидности email (базовая)
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Добавление проверки email
ALTER TABLE orders 
ADD CONSTRAINT check_valid_email 
CHECK (is_valid_email(email));

-- Функция для подсчета общей суммы заказа
CREATE OR REPLACE FUNCTION calculate_order_total(order_id_param UUID)
RETURNS DECIMAL(10,2) AS $$
DECLARE
    total_sum DECIMAL(10,2);
BEGIN
    SELECT COALESCE(SUM(total), 0.00) INTO total_sum
    FROM order_items
    WHERE order_id = order_id_param;
    
    RETURN total_sum;
END;
$$ LANGUAGE plpgsql;

-- Функция для проверки соответствия total_amount сумме элементов
CREATE OR REPLACE FUNCTION check_order_total()
RETURNS TRIGGER AS $$
DECLARE
    calculated_total DECIMAL(10,2);
BEGIN
    calculated_total := calculate_order_total(NEW.id);
    
    IF ABS(NEW.total_amount - calculated_total) > 0.01 THEN
        RAISE EXCEPTION 'Order total_amount (%) does not match sum of items (%)', 
            NEW.total_amount, calculated_total;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для проверки total_amount при вставке/обновлении заказа
CREATE TRIGGER check_order_total_trigger
    BEFORE INSERT OR UPDATE ON orders
    FOR EACH ROW EXECUTE FUNCTION check_order_total();

-- Функция для обновления total_amount при изменении элементов заказа
CREATE OR REPLACE FUNCTION update_order_total_on_item_change()
RETURNS TRIGGER AS $$
DECLARE
    affected_order_id UUID;
    new_total DECIMAL(10,2);
BEGIN
    -- Определяем ID заказа в зависимости от операции
    IF TG_OP = 'DELETE' THEN
        affected_order_id := OLD.order_id;
    ELSE
        affected_order_id := NEW.order_id;
    END IF;
    
    -- Вычисляем новую сумму
    new_total := calculate_order_total(affected_order_id);
    
    -- Обновляем сумму заказа
    UPDATE orders 
    SET total_amount = new_total, updated_at = NOW() 
    WHERE id = affected_order_id;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Триггер для автоматического обновления total_amount при изменении элементов
CREATE TRIGGER update_order_total_on_item_change_trigger
    AFTER INSERT OR UPDATE OR DELETE ON order_items
    FOR EACH ROW EXECUTE FUNCTION update_order_total_on_item_change();

-- Представление для заказов с дополнительной информацией
CREATE OR REPLACE VIEW orders_with_stats AS
SELECT 
    o.id,
    o.customer_id,
    o.email,
    o.status,
    o.total_amount,
    o.currency,
    o.created_at,
    o.updated_at,
    COUNT(oi.id) as items_count,
    COALESCE(SUM(oi.quantity), 0) as total_quantity,
    CASE 
        WHEN COUNT(oa.id) > 0 THEN true 
        ELSE false 
    END as has_shipping_address
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN order_addresses oa ON o.id = oa.order_id AND oa.type = 'shipping'
GROUP BY o.id, o.customer_id, o.email, o.status, o.total_amount, o.currency, o.created_at, o.updated_at;

-- Функция для получения статистики заказов по статусам
CREATE OR REPLACE FUNCTION get_order_statistics()
RETURNS TABLE(
    status VARCHAR(50),
    count BIGINT,
    total_amount DECIMAL(10,2),
    avg_amount DECIMAL(10,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        o.status,
        COUNT(*)::BIGINT as count,
        COALESCE(SUM(o.total_amount), 0.00) as total_amount,
        COALESCE(AVG(o.total_amount), 0.00) as avg_amount
    FROM orders o
    GROUP BY o.status
    ORDER BY count DESC;
END;
$$ LANGUAGE plpgsql;

-- Функция для очистки старых заказов (для maintenance)
CREATE OR REPLACE FUNCTION cleanup_old_orders(older_than_days INTEGER DEFAULT 365)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM orders 
    WHERE created_at < NOW() - INTERVAL '1 day' * older_than_days
    AND status IN ('delivered', 'cancelled', 'refunded');
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Комментарии к таблицам
COMMENT ON TABLE orders IS 'Основная таблица заказов';
COMMENT ON TABLE order_items IS 'Элементы заказов (товары)';
COMMENT ON TABLE order_addresses IS 'Адреса доставки и выставления счетов';

-- Комментарии к столбцам
COMMENT ON COLUMN orders.id IS 'Уникальный идентификатор заказа';
COMMENT ON COLUMN orders.customer_id IS 'Идентификатор клиента';
COMMENT ON COLUMN orders.email IS 'Email клиента';
COMMENT ON COLUMN orders.status IS 'Статус заказа';
COMMENT ON COLUMN orders.total_amount IS 'Общая сумма заказа';
COMMENT ON COLUMN orders.currency IS 'Валюта заказа';

COMMENT ON COLUMN order_items.product_id IS 'Идентификатор товара';
COMMENT ON COLUMN order_items.name IS 'Название товара на момент заказа';
COMMENT ON COLUMN order_items.price IS 'Цена товара за единицу';
COMMENT ON COLUMN order_items.quantity IS 'Количество товара';
COMMENT ON COLUMN order_items.total IS 'Общая стоимость позиции (price * quantity)';

-- Пример данных для тестирования (опционально)
/*
INSERT INTO orders (id, customer_id, email, status, total_amount, currency) 
VALUES 
    ('123e4567-e89b-12d3-a456-426614174000', '123e4567-e89b-12d3-a456-426614174001', 'test@example.com', 'pending', 100.00, 'USD'),
    ('123e4567-e89b-12d3-a456-426614174002', '123e4567-e89b-12d3-a456-426614174003', 'test2@example.com', 'confirmed', 150.00, 'USD');

INSERT INTO order_items (id, order_id, product_id, name, price, quantity, total)
VALUES 
    ('123e4567-e89b-12d3-a456-426614174010', '123e4567-e89b-12d3-a456-426614174000', '123e4567-e89b-12d3-a456-426614174020', 'Test Product 1', 50.00, 2, 100.00),
    ('123e4567-e89b-12d3-a456-426614174011', '123e4567-e89b-12d3-a456-426614174002', '123e4567-e89b-12d3-a456-426614174021', 'Test Product 2', 75.00, 2, 150.00);
*/